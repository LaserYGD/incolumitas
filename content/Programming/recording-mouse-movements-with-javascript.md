Title: Recording Mouse Movements and User Interactions with JavaScript 
Date: 2020-12-24 16:53
Modified: 2020-12-25 23:59
Category: Programming
Tags: JavaScript, Analytics, Mouse, Touch, Mobile
Slug: recording-mouse-movements-with-javascript
Author: Nikolai Tschacher
Summary: In this blog post, I will introduce a JavaScript library that allows to track various user interactions of website visitors. Several key problems that arise when creating a JavaScript analytics application will be discussed and solved in this blog post.

### Motivation

Most JavaScript analytics applications aim to visualize and provide statistics of the browsing behavior of website visitors. This is not my motivation for recording and storing analytics data. Instead, I want to make a *simple* statement on the grounds of user interaction data:

1. Whether the user interaction data seems to be of human nature
2. Or if the data is generated by a automated program - a so called bot

Put differently, I want to **classify user interaction data as either human or bot-like**.

This is a very hard problem. 

Currently, I am in the process of building a well-structured library that allows me to collect and store user interaction data for the next processing step. This technical topic will be the focus of this blog post.

When the point arrives that enough data has been collected, I will have to design a system that classifies the data according to the above criteria. One possible solution would be to create a training set to feed a deep neuronal network. However, the training data must be pre-classified as human or bot-like, which could be quite a daunting task to begin with.

Another problem is, that it is actually not that simple to find a large sample size of bot-generated interaction data, since a lot of bots do not create mouse or key-pressing events.

Only very sophisticated bots actually aim to mimic and replicate human behavior in the sense that the same user interaction events are being generated as as human would when they are browsing the web.

### User Interaction Data

So what kind of user interaction data should be recorded by the JavaScript library? Currently, the JavaScript library captures the following events:

1. `mousemove` Store the (x,y) coordinates of the current mouse cursor
2. `mousedown` Store the (x,y) coordinates of a mouse click
3. `scroll` Store the `document.scrollingElement.scrollLeft` and `document.scrollingElement.scrollTop` quantities
4. `keydown` Store the currently pressed key
5. `resize` Fires when the viewport is resized. The new viewport size is stored
6. `contextmenu` This event is fired when the user makes a right click with the mouse. The coordinates of the click are stored
7. `touchstart` Mobile touch event. This event is generated when the user taps on the screen
8. `touchmove` Mobile touch event. This event arises when the user moves with their fingers across the touch screen
9. `touchcancel` Mobile touch event. Fires when a touch event is canceled
10. `touchend` Mobile touch event. Is fired when the finger is lifted from the touch screen

### When to send analytics data to the server?

One tricky problem with JavaScript analytics applications is the question of when and how to send the recorded data to the server. Obviously, one key requirement is to record user interaction data as long as possible until the point when the user leaves the page.

However, when the recording of user interaction data stops too early, crucial data is missing for analysis. When we record for too long, it can become problematic to send the data to the server. What would be a suitable event to consider for this requirement? A couple of different events can be considered:

1. `beforeunload` Fired right before the window, the document and its resources are about to be unloaded. This is a cancelable event.
2. `unload` Fires when the document or a child resource is being unloaded. This event is fired after the `beforeunload` and `pagehide` event. An error in the event handler will not stop the unloading workflow.
3. `pagehide` event is sent to a Window when the browser hides the current page by presenting a different page from the session's history. When pressing the "back button", this event is fired.
3. `visibilitychange` is fired when the content of a page has become visible or hidden.

This excellent article named ["Don't lose user and app state, use Page Visibility
"](https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/) makes an case for the `visibilitychange` API. No other event should be used to send analytics data to the remote server, especially because the other events fire unreliably.

### How to send the recorded data?

The next question to be answered is how the recorded data should be transmitted to the remote server. There are several possibilities that come to mind:

1. Use the good old `XMLHttpRequest` object to make http requests (ajax)
2. Use the relatively new `fetch()` http API
3. Make use of an `<img>` tag and the `src` attribute to transmit data in the query string
4. Use `navigator.sendBeacon()` to asynchronously send a small amount of data over HTTP to a web server

The `navigator.sendBeacon()` API was introduced exactly for the purpose to asynchronously transmit data before the page is being closed. The mandatory reading list for this topic is the [related MDN page](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon).

> The navigator.sendBeacon() method asynchronously sends a small amount of data over HTTP to a web server. It’s intended to be used in combination with the visibilitychange event (but not with the unload and beforeunload events).

#### Testing `sendBeacon()` behavior with different events

The following simple Express server can be used to listen for incoming POST requests from `navigator.sendBeacon()`. 

Install it with the commands: 

`npm install express body-parser cors` 

and then launch the server with: 

`node server.js`.

```JavaScript
// server.js
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const path = require('path');

const app = express();
const port = 8888;

app.use(express.json());
app.use(cors());
app.use(bodyParser.json({ limit: '2mb' }));
app.use(bodyParser.text());

app.post('/data', (req, res) => {
  console.log(req.body);
  res.status(200).send('ok');
});

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
});
```

The following code snippets are to be executed within the web page. You can also paste them into the developer console directly.

First, let's see how the `visibilitychange` event is handled in JavaScript:

```JavaScript
var n = 0;
document.addEventListener("visibilitychange", function(event) {
  if (document.visibilityState === 'hidden') {
    n++;
    var message = 'visibilitychange - hidden - ' + n;
    navigator.sendBeacon('https://scrapeulous.com:3895/t', message);
  }
})
```

A similar code snippet for the `beforeunload` event:

```JavaScript
var n = 0;
window.addEventListener('beforeunload', function(event) {
  n++;
  var message = 'beforeunload - ' + n;
  navigator.sendBeacon('https://scrapeulous.com:3895/t', message);
})
```

The same logic holds for the `pagehide` and `unload` event and is excluded here for simplicity.

#### Test Results for mobile and desktop browsers

As the code snippets above demonstrate, we hook into an event from the page lifecycle and then attempt to send a small amount of data to our web server.

We consider the event to be a success if BOTH of the following points hold:

1. The browser actually fired the event in question
2. The browser succeeded in sending the data with `navigator.sendBeacon()`

Therefore, it is possible that the browser succeeds in firing the event, but fails to deliver the HTTP request with `navigator.sendBeacon()`. This would be still regarded as an overall failure, regardless that an other transmission method might be successful. 

The different events from above where tested on a desktop computer (Ubuntu 18.04.5 LTS) and on a Android Phone (Motorola g(6)) running Android version 9. On both the desktop and mobile platform, Firefox and Chrome were tested.

With the Chrome browser and the Firefox browser on a Desktop computer (Ubuntu 18.04.5 LTS) the following results were obtained:

| Event                     | Action                         | Desktop Chrome/86.0.4240.75   | Desktop Firefox/84.0 |
|---------------------------|--------------------------------|-------------------------------|----------------------|
| visibilitychange (hidden) | HTML loaded                    | ✗                             | ✗                    |
| visibilitychange (hidden) | Close active Tab               | ✓ (event is triggered twice!) | ✓                    |
| visibilitychange (hidden) | Switch Tab                     | ✓                             | ✓                    |
| visibilitychange (hidden) | Close Browser                  | ✓ (event is triggered twice!) | ✓                    |
| visibilitychange (hidden) | Navigate away by clicking link | ✓                             | ✓                    |
|                           |                                |                               |                      |
| beforeunload              | HTML loaded                    | ✗                             | ✓                    |
| beforeunload              | Close active Tab               | ✓                             | ✓                    |
| beforeunload              | Switch Tab                     | ✗                             | ✗                    |
| beforeunload              | Close Browser                  | ✓                             | ✗                    |
| beforeunload              | Navigate away by clicking link | ✓                             | ✓                    |
|                           |                                |                               |                      |
| unload                    | HTML loaded                    | ✗                             | ✗                    |
| unload                    | Close active Tab               | ✓                             | ✓                    |
| unload                    | Switch Tab                     | ✗                             | ✗                    |
| unload                    | Close Browser                  | ✓                             | ✗                    |
| unload                    | Navigate away by clicking link | ✓                             | ✓                    |
|                           |                                |                               |                      |
| pagehide                  | HTML loaded                    | ✗                             | ✗                    |
| pagehide                  | Close active Tab               | ✓                             | ✓                    |
| pagehide                  | Switch Tab                     | ✗                             | ✗                    |
| pagehide                  | Close Browser                  | ✓                             | ✗                    |
| pagehide                  | Navigate away by clicking link | ✓                             | ✓                    |

It can be seen that the beacon is successfully sent when using the event `visibilitychange`. The other events are not ideal and reliable for transmitting analytics data.

The following data was obtained on the mobile phone with operating system Android 9 on a Moto g(6) device. The behavior of the 
event was tested with different actions on mobile platforms.

| Event                     | Action                         | Mobile Chrome/87.0.4280.101 | Mobile Firefox/84.0 |
|---------------------------|--------------------------------|-----------------------------|---------------------|
| visibilitychange (hidden) | HTML loaded                    | ✗                           | ✗                   |
| visibilitychange (hidden) | Press Home Button              | ✓                           | ✓                   |
| visibilitychange (hidden) | Open Task Management           | ✓                           | ✓                   |
| visibilitychange (hidden) | Close Tab                      | ✓                           | ✓                   |
| visibilitychange (hidden) | Navigate away by clicking link | ✓                           | ✓                   |
|                           |                                |                             |                     |
| beforeunload              | HTML loaded                    | ✗                           | ✗                   |
| beforeunload              | Press Home Button              | ✗                           | ✗                   |
| beforeunload              | Open Task Management           | ✗                           | ✗                   |
| beforeunload              | Close Tab                      | ✗                           | ✗                   |
| beforeunload              | Navigate away by clicking link | ✓                           | ✓                   |
|                           |                                |                             |                     |
| unload                    | HTML loaded                    | ✗                           | ✗                   |
| unload                    | Press Home Button              | ✗                           | ✗                   |
| unload                    | Open Task Management           | ✗                           | ✗                   |
| unload                    | Close Tab                      | ✗                           | ✓                   |
| unload                    | Navigate away by clicking link | ✗ (unreliable)              | ✓                   |
|                           |                                |                             |                     |
| pagehide                  | HTML loaded                    | ✗                           | ✗                   |
| pagehide                  | Press Home Button              | ✗                           | ✗                   |
| pagehide                  | Open Task Management           | ✗                           | ✗                   |
| pagehide                  | Close Tab                      | ✗ (unreliable)              | ✓                   |
| pagehide                  | Navigate away by clicking link | ✓                           | ✓                   |

Again, on both mobile browsers, the `visibilitychange` seems to be the only rational choice when sending analytics data to a remote server.


### Analytics Algorithm

Now that it has been established that it's best to consider the `visibilitychange` event, let's implement a simple algorithm that sends data to our remote server.